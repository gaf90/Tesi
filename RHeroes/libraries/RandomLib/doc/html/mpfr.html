<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>RandomLib: MPFR interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RandomLib</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">MPFR interface </div>  </div>
</div>
<div class="contents">
<div class="textblock"><center> Back to <a class="el" href="otherdist.html">Other random distributions</a>. Forward to <a class="el" href="save.html">Saving and restoring the state</a>. Up to <a class="el" href="index.html#contents">Contents</a>. </center><p>The classes <a class="el" href="classRandomLib_1_1MPFRUniform.html" title="The uniform distribution for MPFR.">RandomLib::MPFRUniform</a>, <a class="el" href="classRandomLib_1_1MPFRExponential.html" title="The exponential distribution for MPFR.">RandomLib::MPFRExponential</a>, and <a class="el" href="classRandomLib_1_1MPFRNormal.html" title="The normal distribution for MPFR.">RandomLib::MPFRNormal</a>, provide a efficient methods of computing random deviates and returning the results in the form of <a href="http://www.mpfr.org">MPFR</a> numbers. These classes (together with <a class="el" href="classRandomLib_1_1MPFRRandom.html" title="Handling random numbers in MPFR.">RandomLib::MPFRRandom</a>) are header-only implementations which do not depend on the rest of RandomLib. In order to use these headers, you can copy them into the directory tree where you are developing an MPFR application (make sure they stay within a directory called RandomLib) and include them with e.g., </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="MPFRNormal_8hpp.html" title="Header for MPFRNormal.">RandomLib/MPFRNormal.hpp</a>&gt;</span>
</pre></div><p>(There are 3 additional classes included in RandomLib: <a class="el" href="classRandomLib_1_1MPFRExponentialL.html" title="The exponential distribution for MPFR (the log method).">RandomLib::MPFRExponentialL</a>, <a class="el" href="classRandomLib_1_1MPFRNormalK.html" title="The normal distribution for MPFR (Kahn algorithm).">RandomLib::MPFRNormalK</a>, and <a class="el" href="classRandomLib_1_1MPFRNormalR.html" title="The normal distribution for MPFR (ratio method).">RandomLib::MPFRNormalR</a>. But these are included for illustrative purposes only and therefore they are marked as <b>deprecated</b> in the documentation.)</p>
<p>For high precision, the time per sample for <a class="el" href="classRandomLib_1_1MPFRUniform.html" title="The uniform distribution for MPFR.">RandomLib::MPFRUniform</a>, <a class="el" href="classRandomLib_1_1MPFRExponential.html" title="The exponential distribution for MPFR.">RandomLib::MPFRExponential</a>, and <a class="el" href="classRandomLib_1_1MPFRNormal.html" title="The normal distribution for MPFR.">RandomLib::MPFRNormal</a> is proportional to the precision where the constant of proportionality is governed by generating the required number of random bits and copying these into the result. Thus, using these methods, the generationn of random numbers in MPFR is amongst the cheapest of operations (cheaper, for example, than multiplication). The timing data is giving in the tables below.</p>
<p>This table gives the time required to generate a random sample from an exponential distribution: </p>
<center> <table class="doxtable">
<caption align="bottom">Times (us) for sampling from the exponential distribution </caption>
<tr>
<th>prec</th><th>(1)</th><th>(2)</th><th>(3)</th><th>(4) </th></tr>
<tr>
<td>4 </td><td></td><td></td><td>0.30</td><td>10  </td></tr>
<tr>
<td>8 </td><td></td><td></td><td>0.30</td><td>7.7  </td></tr>
<tr>
<td>16 </td><td></td><td></td><td>0.30</td><td>7.0  </td></tr>
<tr>
<td>24 </td><td>0.056</td><td>0.21</td><td>0.30</td><td>6.4  </td></tr>
<tr>
<td>32 </td><td></td><td></td><td>0.33</td><td>8.6  </td></tr>
<tr>
<td>48 </td><td></td><td></td><td>0.35</td><td>8.5  </td></tr>
<tr>
<td>53 </td><td>0.079</td><td>0.29</td><td>0.35</td><td>8.5  </td></tr>
<tr>
<td>64 </td><td>0.069</td><td>0.30</td><td>0.35</td><td>8.4  </td></tr>
<tr>
<td>128 </td><td></td><td></td><td>0.37</td><td>13  </td></tr>
<tr>
<td>256 </td><td></td><td></td><td>0.41</td><td>23  </td></tr>
<tr>
<td>1024 </td><td></td><td></td><td>0.64</td><td>82  </td></tr>
<tr>
<td>4096 </td><td></td><td></td><td>1.5 </td><td>520  </td></tr>
<tr>
<td>16384 </td><td></td><td></td><td>4.9 </td><td>5200  </td></tr>
<tr>
<td>65536 </td><td></td><td></td><td>19 </td><td>53000  </td></tr>
<tr>
<td>262144 </td><td></td><td></td><td>81 </td><td>490000  </td></tr>
<tr>
<td>1048576</td><td></td><td></td><td>300 </td><td>4100000 </td></tr>
</table>
</center><p> Key to methods for sampling from the exponential distribution: <br/>
 (1) <a class="el" href="classRandomLib_1_1ExponentialDistribution.html" title="The exponential distribution.">RandomLib::ExponentialDistribution</a>; <br/>
 (2) <a class="el" href="classRandomLib_1_1ExactExponential.html" title="Sample exactly from an exponential distribution.">RandomLib::ExactExponential</a>, with <em>bits</em> = 32; <br/>
 (3) <a class="el" href="classRandomLib_1_1MPFRExponential.html" title="The exponential distribution for MPFR.">RandomLib::MPFRExponential</a>, with <em>bits</em> = 32, which uses the same algorithm as <a class="el" href="classRandomLib_1_1ExactExponential.html" title="Sample exactly from an exponential distribution.">RandomLib::ExactExponential</a>; <br/>
 (4) <a class="el" href="classRandomLib_1_1MPFRExponentialL.html" title="The exponential distribution for MPFR (the log method).">RandomLib::MPFRExponentialL</a>, which uses the same algorithm as <a class="el" href="classRandomLib_1_1ExponentialDistribution.html" title="The exponential distribution.">RandomLib::ExponentialDistribution</a> (taking the log of a uniform deviate). <br/>
</p>
<p>This table gives the time required to generate a random sample from an normal distribution: </p>
<center> <table class="doxtable">
<caption align="bottom">Times (us) for sampling from the norml distribution</caption>
<tr>
<th>prec</th><th>(1)</th><th>(2)</th><th>(3)</th><th>(3')</th><th>(4)</th><th>(4') </th></tr>
<tr>
<td>4 </td><td></td><td></td><td>0.91</td><td>1.2</td><td>0.62 </td><td>2.7  </td></tr>
<tr>
<td>8 </td><td></td><td></td><td>0.91</td><td>1.2</td><td>0.61 </td><td>2.4  </td></tr>
<tr>
<td>16 </td><td></td><td></td><td>0.91</td><td>1.2</td><td>0.61 </td><td>2.6  </td></tr>
<tr>
<td>24 </td><td>0.034</td><td>0.54</td><td>0.91</td><td>1.2</td><td>0.65 </td><td>2.8  </td></tr>
<tr>
<td>32 </td><td></td><td></td><td>0.95</td><td>1.2</td><td>0.92 </td><td>3.0  </td></tr>
<tr>
<td>48 </td><td></td><td></td><td>0.96</td><td>1.3</td><td>0.92 </td><td>3.1  </td></tr>
<tr>
<td>53 </td><td>0.047</td><td>0.61</td><td>0.96</td><td>1.3</td><td>0.93 </td><td>3.2  </td></tr>
<tr>
<td>64 </td><td>0.043</td><td>0.64</td><td>0.97</td><td>1.3</td><td>1.0 </td><td>3.4  </td></tr>
<tr>
<td>128 </td><td></td><td></td><td>0.99</td><td>1.3</td><td>1.2 </td><td>4.8  </td></tr>
<tr>
<td>256 </td><td></td><td></td><td>1.0 </td><td>1.3</td><td>1.5 </td><td>7.7  </td></tr>
<tr>
<td>1024 </td><td></td><td></td><td>1.3 </td><td>1.5</td><td>3.7 </td><td>26  </td></tr>
<tr>
<td>4096 </td><td></td><td></td><td>2.1 </td><td>2.4</td><td>18 </td><td>160  </td></tr>
<tr>
<td>16384 </td><td></td><td></td><td>5.4 </td><td>5.7</td><td>150 </td><td>1600  </td></tr>
<tr>
<td>65536 </td><td></td><td></td><td>19 </td><td>19 </td><td>1300 </td><td>15000  </td></tr>
<tr>
<td>262144 </td><td></td><td></td><td>77 </td><td>76 </td><td>11000</td><td>140000  </td></tr>
<tr>
<td>1048576</td><td></td><td></td><td>300 </td><td>300</td><td>87000</td><td>1000000 </td></tr>
</table>
</center><p> Key to methods for sampling from the normal distribution: <br/>
 (1) <a class="el" href="classRandomLib_1_1NormalDistribution.html" title="Normal deviates.">RandomLib::NormalDistribution</a>; <br/>
 (2) <a class="el" href="classRandomLib_1_1ExactNormal.html" title="Sample exactly from a normal distribution.">RandomLib::ExactNormal</a>, with <em>bits</em> = 32; <br/>
 (3) <a class="el" href="classRandomLib_1_1MPFRNormal.html" title="The normal distribution for MPFR.">RandomLib::MPFRNormal</a>, with <em>bits</em> = 32, which uses the same algorithm as <a class="el" href="classRandomLib_1_1ExactNormal.html" title="Sample exactly from a normal distribution.">RandomLib::ExactNormal</a>; <br/>
 (3') <a class="el" href="classRandomLib_1_1MPFRNormalK.html" title="The normal distribution for MPFR (Kahn algorithm).">RandomLib::MPFRNormalK</a>, with <em>bits</em> = 32, which uses the Kahn algorithm; <br/>
 (4) <a class="el" href="classRandomLib_1_1MPFRNormalR.html" title="The normal distribution for MPFR (ratio method).">RandomLib::MPFRNormalR</a>, which uses the same algorithm as <a class="el" href="classRandomLib_1_1NormalDistribution.html" title="Normal deviates.">RandomLib::NormalDistribution</a> (the ratio method); <br/>
 (4') MPFR's grandom, which uses the polar method. <br/>
</p>
<p>Notes:</p>
<ul>
<li>The timing tests used <a class="el" href="namespaceRandomLib.html" title="Namespace for RandomLib.">RandomLib</a> 1.4, MPFR 3.1.0, g++ 4.6.1 on a 64-bit Intel Xeon 2.66GHz running Linux Fedora Release 15.</li>
<li>Methods (1) use standard algorithms for sampling from these distributions. These are reasonably accurate but do <b>not</b> yield correctly rounded results (in the sense of MPFR).</li>
<li>Methods (2) use adaptions of von Neumann's method. These give correctly rounded results.</li>
<li>Methods (3) adapt methods (2) to MPFR. For high precision, the time scales linearly with precision. Method (3'), which uses <a class="el" href="classRandomLib_1_1MPFRExponential.html" title="The exponential distribution for MPFR.">RandomLib::MPFRExponential</a> internally, is an alternate method of sampling from the normal distribution using Kahn's algorithm. Damien Stehl&eacute; suggested the use of Kahn's algorithm to me. For high precision, the time is proportional to the precision for these methods and they all have the same constant of proportionality.</li>
<li>Methods (4) adapt methods (1) to MPFR. For high precision, the time scales approximately as the 3/2 power of the precision. Method (4') uses the grandom function.</li>
<li><a class="el" href="classRandomLib_1_1MPFRExponential.html" title="The exponential distribution for MPFR.">RandomLib::MPFRExponential</a> and <a class="el" href="classRandomLib_1_1MPFRNormal.html" title="The normal distribution for MPFR.">RandomLib::MPFRNormal</a> have meager internal documentation. Refer to <a class="el" href="classRandomLib_1_1ExactExponential.html" title="Sample exactly from an exponential distribution.">RandomLib::ExactExponential</a> and <a class="el" href="classRandomLib_1_1ExactNormal.html" title="Sample exactly from a normal distribution.">RandomLib::ExactNormal</a> (which implement the same algorithms) for more information.</li>
</ul>
<p>The von Neumann methods work in two phases. (1) Some number of uniform random numbers are consumed to form the initial digits of the random sample. (2) Additional digits are copied directly from the random number generator to the random sample. It is convenient to be able to interrupt the process after phase (1) and the <a class="el" href="classRandomLib_1_1MPFRRandom.html" title="Handling random numbers in MPFR.">RandomLib::MPFRRandom</a> class holds this intermediate object. The utility of <a class="el" href="classRandomLib_1_1MPFRRandom.html" title="Handling random numbers in MPFR.">RandomLib::MPFRRandom</a> is seen by considering Kahn's algorithm for normal sampling: pick <em>y</em> and <em>z</em> from the exponential distribution until (<em>y</em> - 1)<sup>2</sup> &lt; 2<em>z</em> and then return <em>y</em>. If <em>y</em> and <em>z</em> are returned as <a class="el" href="classRandomLib_1_1MPFRRandom.html" title="Handling random numbers in MPFR.">RandomLib::MPFRRandom</a> objects then only sufficient digits need to be generated to determine the acceptance test. If the test passes, then digits only need to be added to <em>y</em> (and not to <em>z</em>). Since the implementation of <a class="el" href="classRandomLib_1_1MPFRNormalK.html" title="The normal distribution for MPFR (Kahn algorithm).">RandomLib::MPFRNormalK</a> for details. <a class="el" href="classRandomLib_1_1MPFRUniform.html" title="The uniform distribution for MPFR.">RandomLib::MPFRUniform</a> is a thin wrapper for <a class="el" href="classRandomLib_1_1MPFRRandom.html" title="Handling random numbers in MPFR.">RandomLib::MPFRRandom</a> which returns samples in [0,1).</p>
<p>The classes <a class="el" href="classRandomLib_1_1MPFRRandom.html" title="Handling random numbers in MPFR.">RandomLib::MPFRRandom</a>, <a class="el" href="classRandomLib_1_1MPFRUniform.html" title="The uniform distribution for MPFR.">RandomLib::MPFRUniform</a>, <a class="el" href="classRandomLib_1_1MPFRExponential.html" title="The exponential distribution for MPFR.">RandomLib::MPFRExponential</a>, <a class="el" href="classRandomLib_1_1MPFRNormal.html" title="The normal distribution for MPFR.">RandomLib::MPFRNormal</a>, and <a class="el" href="classRandomLib_1_1MPFRNormalK.html" title="The normal distribution for MPFR (Kahn algorithm).">RandomLib::MPFRNormalK</a> all take a template parameter <em>bits</em> (default value 32) which gives the number of bits in each "digit" of the <a class="el" href="classRandomLib_1_1MPFRRandom.html" title="Handling random numbers in MPFR.">RandomLib::MPFRRandom</a> object. This must evenly divide GMP_LIMB_BITS. For portability you should not set this to 64. Typically 32 will provide the best efficiency. Smaller values are useful for debugging, for studying algorithmic complexity (see Knuth and Yao, 1976), or if random bits are expensive (e.g., they are being generated by a hardware generator).</p>
<p>Here is an example of using <a class="el" href="classRandomLib_1_1MPFRNormal.html" title="The normal distribution for MPFR.">RandomLib::MPFRNormal</a>:</p>
<div class="fragment"><pre class="fragment"><span class="comment">/**</span>
<span class="comment"> * \file MPFRExample.cpp</span>
<span class="comment"></span>
<span class="comment"> * \brief An example of calling RandomLib::MPFRNormal.</span>
<span class="comment"> *</span>
<span class="comment"> * Compile, link, and run with, e.g.,</span>
<span class="comment"> * g++ -I../include -O2 -o MPFRExample MPFRExample.cpp -lmpfr -lgmp</span>
<span class="comment"> * ./MPFRExample</span>
<span class="comment"> *</span>
<span class="comment"> * $Id: cd1cf122149735ed6136a9df8f1ec8219207dbdc $</span>
<span class="comment"> *</span>
<span class="comment"> * Copyright (c) Charles Karney (2012) &lt;charles@karney.com&gt; and licensed under</span>
<span class="comment"> * the MIT/X11 License.  For more information, see</span>
<span class="comment"> * http://randomlib.sourceforge.net/</span>
<span class="comment"> **********************************************************************/</span>

<span class="preprocessor">#include &lt;cstdio&gt;</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;ctime&gt;</span>                <span class="comment">// for time()</span>
<span class="preprocessor">#include &lt;<a class="code" href="MPFRRandom_8hpp.html" title="Header for MPFRRandom.">RandomLib/MPFRRandom.hpp</a>&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="MPFRNormal_8hpp.html" title="Header for MPFRNormal.">RandomLib/MPFRNormal.hpp</a>&gt;</span>

<span class="keywordtype">int</span> <a class="code" href="MPFRExample_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() {
  gmp_randstate_t r;
  gmp_randinit_mt(r);
  time_t t0 = std::time(0);
  gmp_randseed_ui(r, t0);
  mpfr_t z;

  {
    mpfr_prec_t prec = 240; mpfr_init2(z, prec);
    std::cout &lt;&lt; <span class="stringliteral">&quot;Sample from the unit normal distribution at precision &quot;</span>
              &lt;&lt; prec &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
    <a class="code" href="classRandomLib_1_1MPFRNormal.html" title="The normal distribution for MPFR.">RandomLib::MPFRNormal&lt;&gt;</a> norm; <span class="comment">// bits = 32, by default</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; 10; ++k) {
      norm(z, r, MPFR_RNDN);    <span class="comment">// Obtain a normal deviate</span>
      mpfr_out_str(stdout, 10, 0, z, MPFR_RNDN); std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
    }
  }

  {
    mpfr_prec_t prec = 20; mpfr_set_prec(z, prec);
    std::cout &lt;&lt; <span class="stringliteral">&quot;Sample ranges from the normal distribution at precision &quot;</span>
              &lt;&lt; prec &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
    <a class="code" href="classRandomLib_1_1MPFRNormal.html" title="The normal distribution for MPFR.">RandomLib::MPFRNormal&lt;1&gt;</a> norm; <span class="comment">// choose bits = 1 so that the ranges</span>
    <a class="code" href="classRandomLib_1_1MPFRRandom.html" title="Handling random numbers in MPFR.">RandomLib::MPFRRandom&lt;1&gt;</a> x;    <span class="comment">// are not too narrow</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; 10; ++k) {
      norm(x, r);               <span class="comment">// Obtain an MPFRRandom range</span>
      x(z, MPFR_RNDD);          <span class="comment">// Lower bound of range</span>
      std::cout &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; mpfr_get_d(z, MPFR_RNDD) &lt;&lt; <span class="stringliteral">&quot;,&quot;</span>;
      x(z, MPFR_RNDU);          <span class="comment">// Upper bound of range</span>
      std::cout &lt;&lt; mpfr_get_d(z, MPFR_RNDU) &lt;&lt; <span class="stringliteral">&quot;] -&gt; &quot;</span>;
      x(z, r, MPFR_RNDN);       <span class="comment">// Realize the normal deviate</span>
      mpfr_out_str(stdout, 10, 0, z, MPFR_RNDN); std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
    }
  }

  <span class="comment">// Clean up</span>
  mpfr_clear(z); mpfr_free_cache(); gmp_randclear(r);
}
</pre></div><p>Typical output from this program is: </p>
<div class="fragment"><pre class="fragment">
Sample from the unit normal distribution at precision 240
-5.6692556912807683301494494874784943926662835210924611284269456310097367350e-2
8.5362069032310026750031502283620341952982028910093176612208572465159728631e-1
...
Sample ranges from the normal distribution at precision 20
[0,1] -&gt; 7.2809029e-1
[-2.25,-2.28125] -&gt; -2.2580643
...
</pre></div><center> Back to <a class="el" href="otherdist.html">Other random distributions</a>. Forward to <a class="el" href="save.html">Saving and restoring the state</a>. Up to <a class="el" href="index.html#contents">Contents</a>. </center> </div></div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Mar 20 2012 for RandomLib by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
